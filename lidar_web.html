<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 LIDAR Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            overflow-x: hidden;
        }

        .header {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            width: 100%;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            padding: 20px;
            max-width: 1400px;
            width: 95%;
            margin: 0 auto;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-info {
            background: #2196F3;
            color: white;
        }

        .btn-secondary {
            background: #9E9E9E;
            color: white;
        }

        .canvas-container {
            position: relative;
            background: #1a1a2e;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #lidarCanvas {
            display: block;
            background: #0f0f1e;
            border-radius: 8px;
            max-width: 100%;
            height: auto;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .stat-card h3 {
            font-size: 0.85em;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .stat-card .value {
            font-size: 1.8em;
            font-weight: bold;
        }

        .status {
            text-align: center;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .status.connected {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .status.disconnected {
            background: #ffebee;
            color: #c62828;
        }

        .back-link {
            text-align: center;
            margin-top: 20px;
        }

        .back-link a {
            color: #667eea;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.1em;
        }

        .back-link a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.5em;
            }
            
            .container {
                padding: 15px;
                width: 98%;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 14px;
            }
            
            .stat-card .value {
                font-size: 1.5em;
            }
        }
        
        @media (min-width: 1200px) {
            #lidarCanvas {
                width: 900px;
                height: 900px;
            }
        }
        
        @media (min-width: 768px) and (max-width: 1199px) {
            #lidarCanvas {
                width: 700px;
                height: 700px;
            }
        }
        
        @media (max-width: 767px) {
            #lidarCanvas {
                width: 90vw;
                height: 90vw;
                max-width: 600px;
                max-height: 600px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üì° ESP32 LIDAR Viewer</h1>
        <p>Real-time LIDAR Data Visualization</p>
    </div>

    <div class="container">
        <div class="status connected" id="status">
            ÔøΩ LIDAR ƒëang ho·∫°t ƒë·ªông
        </div>

        <div class="controls">
            <button class="btn btn-info" onclick="clearData()">üßπ X√≥a d·ªØ li·ªáu</button>
            <button class="btn btn-secondary" onclick="goBack()">üè† Quay l·∫°i</button>
        </div>

        <div class="stats">
            <div class="stat-card">
                <h3>S·ªë ƒëi·ªÉm hi·ªán t·∫°i</h3>
                <div class="value" id="pointCount">0</div>
            </div>
            <div class="stat-card">
                <h3>Kho·∫£ng c√°ch ph√≠a tr∆∞·ªõc (-20¬∞ ~ 20¬∞)</h3>
                <div class="value" id="minDistance">-</div>
            </div>
            <div class="stat-card">
                <h3>Kho·∫£ng c√°ch xa nh·∫•t</h3>
                <div class="value" id="maxDistance">-</div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="lidarCanvas"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('lidarCanvas');
        const ctx = canvas.getContext('2d');
        
        // H√†m ƒëi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc canvas responsive
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth - 30; // Tr·ª´ padding
            let size = Math.min(containerWidth, 900); // Max 900px
            
            // ƒêi·ªÅu ch·ªânh theo m√†n h√¨nh
            if (window.innerWidth < 768) {
                size = Math.min(containerWidth, window.innerHeight * 0.6);
            } else if (window.innerWidth < 1200) {
                size = Math.min(containerWidth, 700);
            }
            
            canvas.width = size;
            canvas.height = size;
            
            // V·∫Ω l·∫°i sau khi resize
            drawRadarGrid();
        }
        
        // G·ªçi resize khi load v√† khi thay ƒë·ªïi m√†n h√¨nh
        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);
        
        // =====================================================
        // Config ƒë·ªông t·ª´ server
        // =====================================================
        let lidarConfig = {
            obstacleDistance: 400,
            angleMin: -20,
            angleMax: 20
        };

        // Load config t·ª´ server
        function loadLidarConfig() {
            fetch('/getConfig')
                .then(response => response.json())
                .then(config => {
                    lidarConfig.obstacleDistance = config.LIDAR_OBSTACLE_DISTANCE || 400;
                    lidarConfig.angleMin = config.LIDAR_DETECTION_ANGLE_MIN || -20;
                    lidarConfig.angleMax = config.LIDAR_DETECTION_ANGLE_MAX || 20;
                    console.log(`[LIDAR Config] Loaded: Distance=${lidarConfig.obstacleDistance}mm, Angle=[${lidarConfig.angleMin}¬∞ to ${lidarConfig.angleMax}¬∞]`);
                })
                .catch(error => {
                    console.error('Error loading LIDAR config:', error);
                });
        }

        // Load config khi trang load v√† reload m·ªói 5 gi√¢y
        loadLidarConfig();
        setInterval(loadLidarConfig, 5000);
        
        // T√≠nh to√°n center v√† radius ƒë·ªông
        function getCanvasMetrics() {
            return {
                centerX: canvas.width / 2,
                centerY: canvas.height / 2,
                maxRadius: Math.min(canvas.width, canvas.height) / 2 - 20
            };
        }

        // V·∫Ω l∆∞·ªõi radar n·ªÅn
        function drawRadarGrid() {
            const { centerX, centerY, maxRadius } = getCanvasMetrics();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // V·∫Ω c√°c v√≤ng tr√≤n ƒë·ªìng t√¢m
            ctx.strokeStyle = '#00ff0040';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 4; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, (maxRadius / 4) * i, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            // V·∫Ω c√°c tr·ª•c g√≥c (m·ªói 30 ƒë·ªô)
            ctx.strokeStyle = '#00ff0030';
            for (let angle = 0; angle < 360; angle += 30) {
                const rad = (angle - 90) * Math.PI / 180;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + maxRadius * Math.cos(rad),
                    centerY + maxRadius * Math.sin(rad)
                );
                ctx.stroke();
            }
            
            // V·∫Ω ch·ªØ N, S, E, W
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            ctx.fillText('N', centerX, centerY - maxRadius - 10);
            ctx.fillText('S', centerX, centerY + maxRadius + 10);
            ctx.fillText('E', centerX + maxRadius + 10, centerY);
            ctx.fillText('W', centerX - maxRadius - 10, centerY);
            
            // V·∫Ω ƒëi·ªÉm trung t√¢m
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
            ctx.fill();
        }

        // V·∫Ω c√°c ƒëi·ªÉm LIDAR
        function drawLidarPoints(points) {
            if (!points || points.length === 0) return;
            
            const { centerX, centerY, maxRadius } = getCanvasMetrics();
            
            let minDistFront = Infinity;  // Kho·∫£ng c√°ch g·∫ßn nh·∫•t ph√≠a tr∆∞·ªõc
            let maxDist = 0;
            const DANGER_DISTANCE = lidarConfig.obstacleDistance;  // ƒê·ªçc t·ª´ config ƒë·ªông
            const ANGLE_MIN = lidarConfig.angleMin;
            const ANGLE_MAX = lidarConfig.angleMax;
            
            points.forEach(point => {
                const angle = point.angle;
                const distance = point.distance;
                const age = point.age || 0;
                
                // Ki·ªÉm tra n·∫øu g√≥c trong kho·∫£ng ƒë∆∞·ª£c c·∫•u h√¨nh (v√πng ph√°t hi·ªán)
                // X·ª≠ l√Ω c·∫£ g√≥c √¢m v√† d∆∞∆°ng, v√≠ d·ª• -20¬∞ ƒë·∫øn 20¬∞
                let isInDetectionZone = false;
                
                if (ANGLE_MIN < 0 && ANGLE_MAX > 0) {
                    // Tr∆∞·ªùng h·ª£p g√≥c qua 0¬∞ (v√≠ d·ª•: -20¬∞ ƒë·∫øn 20¬∞)
                    // Ch·∫•p nh·∫≠n g√≥c trong kho·∫£ng [-20, 20] ho·∫∑c [340, 360] v√† [0, 20]
                    if ((angle >= ANGLE_MIN && angle <= ANGLE_MAX) ||
                        (angle >= (360 + ANGLE_MIN) && angle <= 360) ||
                        (angle >= 0 && angle <= ANGLE_MAX)) {
                        isInDetectionZone = true;
                    }
                } else {
                    // Tr∆∞·ªùng h·ª£p b√¨nh th∆∞·ªùng (v√≠ d·ª•: 30¬∞ ƒë·∫øn 60¬∞)
                    if (angle >= ANGLE_MIN && angle <= ANGLE_MAX) {
                        isInDetectionZone = true;
                    }
                }
                
                // T√≠nh t·ªça ƒë·ªô tr√™n canvas (g√≥c 0¬∞ = ph√≠a B·∫Øc)
                const angleRad = (angle - 90) * Math.PI / 180;
                
                // Scale kho·∫£ng c√°ch (gi·∫£ s·ª≠ max = 4000mm)
                const maxDistance = 4000;
                const radius = (distance / maxDistance) * maxRadius;
                
                const x = centerX + radius * Math.cos(angleRad);
                const y = centerY + radius * Math.sin(angleRad);
                
                // M√†u s·∫Øc v√† ƒë·ªô m·ªù d·∫ßn theo th·ªùi gian
                const alpha = Math.max(0, 1 - age / 2.0); // M·ªù d·∫ßn trong 2 gi√¢y
                
                // C·∫¢NH B√ÅO: N·∫øu trong v√πng ph√°t hi·ªán v√† kho·∫£ng c√°ch < ng∆∞·ª°ng ‚Üí M√ÄU ƒê·ªé
                if (isInDetectionZone && distance < DANGER_DISTANCE) {
                    // M√†u ƒë·ªè v·ªõi ƒë·ªô s√°ng t√πy theo th·ªùi gian
                    if (age < 0.5) {
                        ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`; // ƒê·ªè s√°ng
                    } else if (age < 1.0) {
                        ctx.fillStyle = `rgba(220, 0, 0, ${alpha})`; // ƒê·ªè trung b√¨nh
                    } else {
                        ctx.fillStyle = `rgba(180, 0, 0, ${alpha})`; // ƒê·ªè t·ªëi
                    }
                } else {
                    // M√†u xanh b√¨nh th∆∞·ªùng
                    if (age < 0.5) {
                        ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;
                    } else if (age < 1.0) {
                        ctx.fillStyle = `rgba(0, 200, 0, ${alpha})`;
                    } else {
                        ctx.fillStyle = `rgba(0, 150, 0, ${alpha})`;
                    }
                }
                
                // V·∫Ω ƒëi·ªÉm (l·ªõn h∆°n n·∫øu l√† c·∫£nh b√°o)
                ctx.beginPath();
                const pointSize = (isInDetectionZone && distance < DANGER_DISTANCE) ? 6 : 4;
                ctx.arc(x, y, pointSize, 0, 2 * Math.PI);
                ctx.fill();
                
                // Ch·ªâ t√≠nh kho·∫£ng c√°ch g·∫ßn nh·∫•t trong v√πng ph√°t hi·ªán ƒë∆∞·ª£c c·∫•u h√¨nh
                if (isInDetectionZone) {
                    if (distance < minDistFront) minDistFront = distance;
                }
                
                // C·∫≠p nh·∫≠t max distance (to√†n b·ªô)
                if (distance > maxDist) maxDist = distance;
            });
            
            // C·∫≠p nh·∫≠t stats
            document.getElementById('pointCount').textContent = points.length;
            
            // Hi·ªÉn th·ªã kho·∫£ng c√°ch ph√≠a tr∆∞·ªõc v·ªõi m√†u c·∫£nh b√°o n·∫øu < ng∆∞·ª°ng
            const minDistText = minDistFront === Infinity ? '-' : minDistFront.toFixed(0) + ' mm';
            const minDistElement = document.getElementById('minDistance');
            minDistElement.textContent = minDistText;
            
            // Thay ƒë·ªïi m√†u n·ªÅn c·ªßa stat card n·∫øu nguy hi·ªÉm
            const minDistCard = minDistElement.parentElement;
            if (minDistFront < DANGER_DISTANCE && minDistFront !== Infinity) {
                minDistCard.style.background = 'linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%)';
            } else {
                minDistCard.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            }
            
            document.getElementById('maxDistance').textContent = maxDist === 0 ? '-' : maxDist.toFixed(0) + ' mm';
        }

        // Fetch d·ªØ li·ªáu t·ª´ server
        function fetchLidarData() {
            fetch('/getLidarData')
                .then(response => response.json())
                .then(data => {
                    drawRadarGrid();
                    
                    // S·ª≠ d·ª•ng config ƒë·ªông
                    const angleMin = lidarConfig.angleMin;
                    const angleMax = lidarConfig.angleMax;
                    const obstacleDistance = lidarConfig.obstacleDistance;
                    
                    // T√≠nh kho·∫£ng c√°ch g·∫ßn nh·∫•t trong v√πng ƒë∆∞·ª£c c·∫•u h√¨nh
                    let minDistance = 9999;
                    let hasObstacle = false;
                    
                    if (data.points && data.points.length > 0) {
                        data.points.forEach(point => {
                            const angle = point.angle;
                            const distance = point.distance;
                            
                            // Ki·ªÉm tra g√≥c trong v√πng ph√°t hi·ªán (x·ª≠ l√Ω c·∫£ g√≥c √¢m)
                            let isInZone = false;
                            
                            if (angleMin < 0 && angleMax > 0) {
                                // Tr∆∞·ªùng h·ª£p g√≥c qua 0¬∞ (v√≠ d·ª•: -20¬∞ ƒë·∫øn 20¬∞)
                                if ((angle >= angleMin && angle <= angleMax) ||
                                    (angle >= (360 + angleMin) && angle <= 360) ||
                                    (angle >= 0 && angle <= angleMax)) {
                                    isInZone = true;
                                }
                            } else {
                                // Tr∆∞·ªùng h·ª£p b√¨nh th∆∞·ªùng
                                if (angle >= angleMin && angle <= angleMax) {
                                    isInZone = true;
                                }
                            }
                            
                            // Ch·ªâ x√©t c√°c ƒëi·ªÉm trong v√πng ƒë∆∞·ª£c c·∫•u h√¨nh
                            if (isInZone) {
                                if (distance < minDistance) {
                                    minDistance = distance;
                                }
                                if (distance < obstacleDistance) {
                                    hasObstacle = true;
                                }
                            }
                        });
                    }
                    
                    // G·ª≠i tr·∫°ng th√°i v·∫≠t c·∫£n l√™n server (ƒë·ªÉ navigation system bi·∫øt)
                    updateLidarObstacle(hasObstacle, minDistance);
                    
                    // V·∫Ω c√°c ƒëi·ªÉm LIDAR
                    drawLidarPoints(data.points);
                    
                    // C·∫≠p nh·∫≠t status
                    const statusDiv = document.getElementById('status');
                    if (data.connected) {
                        statusDiv.className = 'status connected';
                        statusDiv.textContent = 'üü¢ LIDAR ƒëang ho·∫°t ƒë·ªông';
                    } else {
                        statusDiv.className = 'status disconnected';
                        statusDiv.textContent = 'üî¥ Ch∆∞a k·∫øt n·ªëi';
                    }
                })
                .catch(error => {
                    console.error('Error fetching LIDAR data:', error);
                });
        }

        // G·ª≠i tr·∫°ng th√°i v·∫≠t c·∫£n l√™n server
        function updateLidarObstacle(detected, minDistance) {
            // Log ƒë·ªÉ debug
            if (detected) {
                console.log(`üö® SENDING OBSTACLE ALERT: detected=${detected}, distance=${minDistance.toFixed(0)}mm`);
            }
            
            const formData = new FormData();
            formData.append('detected', detected);
            formData.append('min_distance', minDistance);
            
            fetch('/updateLidarObstacle', {
                method: 'POST',
                body: formData
            }).catch(error => {
                console.error('Error updating LIDAR obstacle:', error);
            });
        }

        // X√≥a d·ªØ li·ªáu
        function clearData() {
            fetch('/clearLidarData', { method: 'POST' })
                .then(response => response.text())
                .then(msg => {
                    console.log(msg);
                    drawRadarGrid();
                    document.getElementById('pointCount').textContent = '0';
                    document.getElementById('minDistance').textContent = '-';
                    document.getElementById('maxDistance').textContent = '-';
                })
                .catch(error => console.error('Error clearing data:', error));
        }

        // Quay l·∫°i trang ch·ªß
        function goBack() {
            window.location.href = '/';
        }

        // Kh·ªüi t·∫°o - T·ª± ƒë·ªông b·∫Øt ƒë·∫ßu LIDAR khi load trang
        drawRadarGrid();
        
        // B·∫Øt ƒë·∫ßu LIDAR ngay khi v√†o trang
        fetch('/startLidar', { method: 'POST' })
            .then(response => response.text())
            .then(msg => {
                console.log('[AUTO-START]', msg);
            })
            .catch(error => console.error('Error auto-starting LIDAR:', error));
        
        // T·ª± ƒë·ªông fetch d·ªØ li·ªáu m·ªói 100ms
        setInterval(fetchLidarData, 100);
    </script>
</body>
</html>
