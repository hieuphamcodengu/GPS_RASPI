<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
  <title>ESP32 Map Controller</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      font-family: Arial, sans-serif;
      background: #f9fafc;
      color: #333;
    }

    .container {
      max-width: 800px;
      margin: auto;
      padding: 10px;
    }

    h2 {
      text-align: center;
      color: #1a73e8;
    }

    #map {
      width: 100%;
      height: 60vh;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }

    .buttons, .map-types {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      margin-top: 10px;
    }

    button {
      flex: 1;
      margin: 5px;
      padding: 10px;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      background-color: #1a73e8;
      color: white;
      transition: 0.3s;
    }

    button:hover {
      background-color: #0d47a1;
    }

    .map-types button {
      background-color: #ccc;
      color: #333;
    }

    .map-types button.active {
      background-color: #1a73e8;
      color: white;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
      background: #fff;
      border-radius: 6px;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    th, td {
      border: 1px solid #ddd;
      text-align: center;
      padding: 8px;
    }

    th {
      background-color: #1a73e8;
      color: white;
    }

    #directions {
      background: #fff;
      margin-top: 15px;
      border-radius: 8px;
      padding: 10px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    #directions ul {
      list-style-type: none;
      padding-left: 0;
    }

    #directions li {
      margin-bottom: 6px;
      padding: 5px 10px;
      border-left: 4px solid #1a73e8;
      background: #f2f4f8;
    }

    @media (max-width: 768px) {
      button { flex: 100%; font-size: 14px; }
      #map { height: 55vh; }
    }

    /* Debug Panel Styles */
    #debugPanel {
      scrollbar-width: thin;
      scrollbar-color: #0f0 #263238;
      overflow-y: auto;
      overflow-x: hidden;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    #debugPanel::-webkit-scrollbar {
      width: 8px;
    }
    
    #debugPanel::-webkit-scrollbar-track {
      background: #263238;
    }
    
    #debugPanel::-webkit-scrollbar-thumb {
      background: #0f0;
      border-radius: 4px;
    }
    
    #debugContent {
      word-wrap: break-word;
      overflow-wrap: break-word;
      white-space: pre-wrap;
    }
    
    #debugContent div {
      padding: 2px 0;
      line-height: 1.4;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>üìç ESP32 Real-time GPS Tracker</h2>

    <div style="margin-top: 10px; text-align: center;">
      <strong>Yaw:</strong> <span id="yawValue">0.00</span>¬∞
    </div>

    <div style="display: flex; gap: 20px; align-items: flex-start;">
      <div style="flex: 1; min-width: 180px;">
        <div style="background: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); padding: 16px;">
          <h3 style="text-align:center; color:#1a73e8; margin-bottom:12px;">Control Panel</h3>
          <button id="btnStart" style="width:100%; margin-bottom:8px;" disabled>B·∫Øt ƒë·∫ßu</button>
          <button id="btnPause" style="width:100%; margin-bottom:8px; background-color:#ff9800; color:white;" disabled>T·∫°m d·ª´ng</button>
          <button id="btnStop" style="width:100%; margin-bottom:8px; background-color:#ff5252; color:white;" disabled>D·ª´ng</button>
          <button id="btnDetection" style="width:100%; background-color:#4CAF50; color:white;" onclick="goToDetection()">üéØ Detection</button>
        </div>
      </div>
      <div style="flex: 2;">
        <!-- Debug Panel -->
        <div style="background: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); padding: 16px; margin-bottom: 16px;">
          <h3 style="text-align:center; color:#1a73e8; margin-top:0; margin-bottom:12px;">üìü Tr·∫°ng th√°i xe</h3>
          <div id="debugPanel" style="background: #263238; color: #0f0; font-family: 'Courier New', monospace; font-size: 13px; padding: 12px; border-radius: 4px; min-height: 120px; max-height: 200px; overflow-y: auto;">
            <div id="debugContent">Ch·ªù l·ªánh...</div>
          </div>
        </div>
        <!-- Ph·∫ßn b·∫£n ƒë·ªì, n√∫t, b·∫£ng t·ªça ƒë·ªô, ch·ªâ d·∫´n di chuy·ªÉn s·∫Ω n·∫±m ·ªü ƒë√¢y -->
        <div id="logPanel" style="background:#fff; border-radius:8px; box-shadow:0 1px 3px rgba(0,0,0,0.1); min-height:60px; font-size:13px; color:#444; padding:12px; display:none;"></div>
      </div>
    </div>

    <!-- üåç Thanh ch·ªçn lo·∫°i b·∫£n ƒë·ªì -->
    <div class="map-types">
      <button onclick="setMapType('roadmap')" class="active">üó∫Ô∏è Roadmap</button>
      <button onclick="setMapType('satellite')">üåç Satellite</button>
      <button onclick="setMapType('hybrid')">üß≠ Hybrid</button>
      <button onclick="setMapType('terrain')">üèîÔ∏è Terrain</button>
    </div>

    <div id="map"></div>

    <div class="buttons">
      <button onclick="clearRoute()">Clear Route</button>
      <button onclick="showCoordinates()">Show Coordinates</button>
      <button onclick="calculateDirections()">Calculate Directions</button>
    </div>

    <table id="coordinatesTable" style="display:none;">
      <thead><tr><th>Latitude</th><th>Longitude</th></tr></thead>
      <tbody></tbody>
    </table>

    <div id="directions" style="display:none;">
      <h3>Movement Directions</h3>
      <ul id="directionsList"></ul>
    </div>
  </div>

  <script>
  let map, currentMarker, markers = [], markerObjects = [], routePath;
  let dis = [], dir = [], dir_value = [];
  let routeLines = [];  // M·∫£ng l∆∞u c√°c ƒë∆∞·ªùng n·ªëi (ƒë·ªè v√† xanh)

  // Tr·∫°ng th√°i ƒëi·ªÅu khi·ªÉn
  let routeReady = false;
  let started = false;
  let paused = false;
  let statusUpdateInterval = null;

    function initMap() {
      const location = { lat: 21.0278, lng: 105.8342 };
      map = new google.maps.Map(document.getElementById('map'), {
        zoom: 15,
        center: location,
        mapTypeId: 'roadmap'
      });

      currentMarker = new google.maps.Marker({ position: location, map, title: "Current Position" });

      map.addListener("click", (event) => {
        addMarker(event.latLng);
        drawRoute();
      });

  fetchGpsData();
  fetchYawData();
    }

    // üåç Chuy·ªÉn lo·∫°i b·∫£n ƒë·ªì
    function setMapType(type) {
      map.setMapTypeId(type);
      document.querySelectorAll('.map-types button').forEach(b => b.classList.remove('active'));
      const btn = [...document.querySelectorAll('.map-types button')].find(b => b.textContent.includes(type.charAt(0).toUpperCase()));
      if (btn) btn.classList.add('active');
    }

    function addMarker(location) {
      const marker = new google.maps.Marker({ position: location, map });
      markerObjects.push(marker);
      markers.push(location);
      addRow(location.lat(), location.lng());
    }

    function drawRoute() {
      if (routePath) routePath.setMap(null);
      routePath = new google.maps.Polyline({
        path: markers, strokeColor: "#FF0000", strokeOpacity: 1.0, strokeWeight: 2
      });
      routePath.setMap(map);
    }

    function clearRoute() {
      if (routePath) routePath.setMap(null);  // X√≥a ƒë∆∞·ªùng ƒëi
      markerObjects.forEach(m => m.setMap(null));  // X√≥a markers

      // X√≥a c√°c ƒë∆∞·ªùng n·ªëi m√†u ƒë·ªè v√† xanh
      routeLines.forEach(line => line.setMap(null));  // X√≥a ƒë∆∞·ªùng n·ªëi
      routeLines = [];  // Reset l·∫°i m·∫£ng ch·ª©a c√°c ƒë∆∞·ªùng n·ªëi
      
  markerObjects = [];
  markers = [];
  dis = [];
  dir = [];
  dir_value = [];
  routeReady = false;
  started = false;
  updateControlButtons();
      
      // X√≥a b·∫£ng t·ªça ƒë·ªô v√† ch·ªâ d·∫´n di chuy·ªÉn
      document.querySelector("#coordinatesTable tbody").innerHTML = "";
      document.getElementById("directionsList").innerHTML = "";
      document.getElementById("directions").style.display = "none";
    }

    function addRow(lat, lng) {
      const row = document.querySelector("#coordinatesTable tbody").insertRow();
      row.insertCell(0).textContent = lat.toFixed(6);
      row.insertCell(1).textContent = lng.toFixed(6);
    }

    function showCoordinates() {
      document.getElementById("coordinatesTable").style.display = "table";
    }

    function calcDistance(p1, p2) {
      const R = 6371e3;
      const dLat = (p2.lat()-p1.lat())*Math.PI/180;
      const dLon = (p2.lng()-p1.lng())*Math.PI/180;
      const a = Math.sin(dLat/2)**2 + Math.cos(p1.lat()*Math.PI/180)*Math.cos(p2.lat()*Math.PI/180)*Math.sin(dLon/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    function calcAngle(p1, p2, p3) {
      const toXY = (p) => {
        const R = 6371e3;
        const x = R * (p.lng() * Math.PI / 180) * Math.cos(p.lat() * Math.PI / 180);
        const y = R * (p.lat() * Math.PI / 180);
        return { x, y };
      };

      const P1 = toXY(p1), P2 = toXY(p2), P3 = toXY(p3);

      const V1x = P2.x - P1.x, V1y = P2.y - P1.y;
      const V2x = P3.x - P2.x, V2y = P3.y - P2.y;

      const dotProduct = V1x * V2x + V1y * V2y;
      const lenV1 = Math.sqrt(V1x * V1x + V1y * V1y);
      const lenV2 = Math.sqrt(V2x * V2x + V2y * V2y);

      const angle = Math.acos(dotProduct / (lenV1 * lenV2)) * (180 / Math.PI);
      const crossProduct = V1x * V2y - V1y * V2x;
      const direction = crossProduct > 0 ? -1 : (crossProduct < 0 ? 1 : 0);

      return { angle, dir: direction };
    }

    function calculateDirections() {
      const directionsDiv = document.getElementById("directions");
      const list = document.getElementById("directionsList");
      list.innerHTML = "";  // Clear previous directions

      let currentLat = null, currentLng = null;
      fetch("/getGpsData")
        .then(response => response.text())
        .then(data => {
          [currentLat, currentLng] = data.split(",").map(parseFloat);
          if (!currentLat || !currentLng) {
            alert("‚ö†Ô∏è GPS kh√¥ng h·ª£p l·ªá.");
            return;
          }

          const currentPoint = new google.maps.LatLng(currentLat, currentLng);
          const fullMarkers = [currentPoint, ...markers];  // Th√™m ƒëi·ªÉm hi·ªán t·∫°i v√†o danh s√°ch markers

          if (fullMarkers.length < 2) {
            alert("Need at least 1 destination point!");
            return;
          }

          dis = []; dir = []; dir_value = [];

          // B∆∞·ªõc 1Ô∏è‚É£: T√≠nh to√°n g√≥c quay v√† di chuy·ªÉn t·ª´ P1 ‚Üí P2, P2 ‚Üí P3 ...
          for (let i = 1; i < fullMarkers.length; i++) {
            const a = fullMarkers[i - 1], b = fullMarkers[i];
            const distance = calcDistance(a, b);  // T√≠nh kho·∫£ng c√°ch gi·ªØa 2 ƒëi·ªÉm
            const turn = calcAngle(a, b, fullMarkers[i + 1] || b);  // T√≠nh g√≥c quay (n·∫øu c√≥ ƒëi·ªÉm ti·∫øp theo)

            if (distance !== 0) {
              dis.push(distance);  // L∆∞u kho·∫£ng c√°ch v√†o m·∫£ng dis
              dir.push(turn.dir);  // L∆∞u h∆∞·ªõng quay v√†o m·∫£ng dir
              dir_value.push(turn.angle);  // L∆∞u g√≥c quay v√†o m·∫£ng dir_value

              // Th√™m ch·ªâ d·∫´n di chuy·ªÉn v√†o danh s√°ch
              const li = document.createElement("li");
              const textDir = turn.dir === 1 ? "Turn right" : turn.dir === -1 ? "Turn left" : "Go straight";
              li.textContent = `Move ${distance.toFixed(2)} m and ${textDir} (${turn.angle.toFixed(2)}¬∞)`;
              list.appendChild(li);

              // V·∫Ω ƒë∆∞·ªùng gi·ªØa c√°c ƒëi·ªÉm n·ªëi
              const color = i === 1 ? "#00FF00" : "#FF0000";  // M√†u xanh l√° cho ƒë∆∞·ªùng n·ªëi t·ª´ P1 ƒë·∫øn P2
              const line = new google.maps.Polyline({
                path: [a, b],
                strokeColor: color,
                strokeOpacity: 1.0,
                strokeWeight: 3
              });
              line.setMap(map);
              routeLines.push(line);  // L∆∞u v√†o m·∫£ng routeLines
            }
          }

          // B∆∞·ªõc 2Ô∏è‚É£: ƒêo·∫°n cu·ªëi c√πng (di chuy·ªÉn v√† d·ª´ng l·∫°i)
          const last = fullMarkers.length - 1;
          const distEnd = calcDistance(fullMarkers[last - 1], fullMarkers[last]);

          if (distEnd !== 0) {
            dis.push(distEnd);  // L∆∞u kho·∫£ng c√°ch cu·ªëi c√πng
            dir.push(0);  // Kh√¥ng quay ·ªü ƒëo·∫°n cu·ªëi
            dir_value.push(0);  // Kh√¥ng quay
          }

          // X√≥a gi√° tr·ªã cu·ªëi c√πng n·∫øu kh√¥ng c·∫ßn thi·∫øt (n·∫øu kh√¥ng c√≥ di chuy·ªÉn)
          if (dis.length > 1) {
            dis.pop();
            dir.pop();
            dir_value.pop();
          }

          // X·ª≠ l√Ω NaN v√† thay th·∫ø b·∫±ng 0 (tr√°nh hi·ªÉn th·ªã NaN)
          dir_value.forEach((value, index) => {
            if (isNaN(value)) {
              dir_value[index] = 0;
            }
          });

          // In c√°c m·∫£ng dis, dir, dir_value ra console ƒë·ªÉ ki·ªÉm tra
          console.log("dis:", dis);
          console.log("dir:", dir);
          console.log("dir_value:", dir_value);
          displayMovementDirections();
          directionsDiv.style.display = "block";  
          sendDataToESP32();  // G·ª≠i d·ªØ li·ªáu ƒë·∫øn ESP32
          routeReady = true;
          started = false;
          paused = false;
          updateControlButtons();
          updateDebugPanel("‚úÖ Route ƒë√£ ƒë∆∞·ª£c t√≠nh to√°n. Nh·∫•n 'B·∫Øt ƒë·∫ßu' ƒë·ªÉ kh·ªüi h√†nh!");
        })
        .catch(error => {
          console.error('Error fetching GPS data:', error);
          alert("‚ùå Kh√¥ng th·ªÉ l·∫•y t·ªça ƒë·ªô GPS t·ª´ ESP32.");
        });
    }

    function displayMovementDirections() {
      const directionsDiv = document.getElementById("directions");
      const list = document.getElementById("directionsList");

      // Clear any previous directions
      list.innerHTML = "";

      // Hi·ªÉn th·ªã c√°c ch·ªâ d·∫´n di chuy·ªÉn
      for (let i = 0; i < dis.length; i++) {
        const li = document.createElement("li");

        if (i === dis.length - 1) {
          // D√≤ng cu·ªëi c√πng: di chuy·ªÉn v√† d·ª´ng l·∫°i
          li.textContent = `Move ${dis[i].toFixed(2)} m then STOP`;
        } else {
          // C√°c d√≤ng di chuy·ªÉn c√≤n l·∫°i
          const textDir = dir[i] === 1 ? "Turn right" : dir[i] === -1 ? "Turn left" : "Go straight";
          li.textContent = `Move ${dis[i].toFixed(2)} m and ${textDir} (${dir_value[i].toFixed(2)}¬∞)`;
        }

        list.appendChild(li);
      }

      // Hi·ªÉn th·ªã ph·∫ßn ch·ªâ d·∫´n
      directionsDiv.style.display = "block";
    }

    function sendDataToESP32() {
      const params = new URLSearchParams({
        dis: dis.join(","), dir: dir.join(","), dir_value: dir_value.join(",")
      });
      fetch("/postData", { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded" }, body: params })
        .then(r => r.text())
        .then(console.log)
        .catch(console.error);
    }

    function fetchGpsData() {
      setInterval(() => {
        fetch("/getGpsData").then(r => r.text()).then(data => {
          const [lat, lng] = data.split(",").map(parseFloat);
          const loc = new google.maps.LatLng(lat, lng);
          if (currentMarker) currentMarker.setMap(null);
          currentMarker = new google.maps.Marker({ position: loc, map, title: "Current Position" });
          map.setCenter(loc);
        }).catch(console.error);
      }, 5000);
    }

    function fetchYawData() {
      setInterval(() => {
        fetch("/getYaw")
          .then(r => r.text())
          .then(yaw => {
            document.getElementById("yawValue").textContent = yaw;
          })
          .catch(console.error);
      }, 1000); // c·∫≠p nh·∫≠t m·ªói 1 gi√¢y
    }

    // H√†m c·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t ƒëi·ªÅu khi·ªÉn
    function updateControlButtons() {
      const btnStart = document.getElementById("btnStart");
      const btnPause = document.getElementById("btnPause");
      const btnStop = document.getElementById("btnStop");
      // B·∫Øt ƒë·∫ßu ch·ªâ s√°ng khi ƒë√£ c√≥ route (sau Calculate Directions), ch∆∞a b·∫Øt ƒë·∫ßu ho·∫∑c ƒë√£ d·ª´ng
      btnStart.disabled = !routeReady || (started && !paused);
      // T·∫°m d·ª´ng ch·ªâ s√°ng khi ƒë√£ b·∫Øt ƒë·∫ßu v√† ch∆∞a pause
      btnPause.disabled = !started || paused;
      btnPause.textContent = paused ? "‚ñ∂Ô∏è Ti·∫øp t·ª•c" : "‚è∏Ô∏è T·∫°m d·ª´ng";
      // D·ª´ng ch·ªâ s√°ng khi ƒë√£ b·∫Øt ƒë·∫ßu
      btnStop.disabled = !started;
    }

    // C·∫≠p nh·∫≠t debug panel
    function updateDebugPanel(message) {
      const debugContent = document.getElementById("debugContent");
      const debugPanel = document.getElementById("debugPanel");
      const timestamp = new Date().toLocaleTimeString();
      const newLine = document.createElement("div");
      newLine.textContent = `[${timestamp}] ${message}`;
      newLine.style.wordWrap = "break-word";
      newLine.style.overflowWrap = "break-word";
      
      debugContent.appendChild(newLine);
      
      // Auto scroll to bottom
      debugPanel.scrollTop = debugPanel.scrollHeight;
      
      // Gi·ªØ t·ªëi ƒëa 30 d√≤ng ƒë·ªÉ tr√°nh tr√†n
      const maxLines = 30;
      while (debugContent.children.length > maxLines) {
        debugContent.removeChild(debugContent.firstChild);
      }
    }

    // Fetch route status t·ª´ server
    function fetchRouteStatus() {
      fetch("/getRouteStatus")
        .then(r => r.json())
        .then(status => {
          if (status.running) {
            const step = status.current_step;
            const total = status.total_steps;
            const action = status.current_action;
            const remaining = status.distance_remaining;
            
            let message = `[B∆∞·ªõc ${step}/${total}] ${action}`;
            if (remaining > 0) {
              message += ` (c√≤n ${remaining.toFixed(2)}m)`;
            }
            
            // Ch·ªâ update n·∫øu message kh√°c v·ªõi d√≤ng cu·ªëi c√πng
            const debugContent = document.getElementById("debugContent");
            const lastLine = debugContent.lastChild;
            if (!lastLine || !lastLine.textContent.includes(action)) {
              updateDebugPanel(message);
            }
          } else if (status.stopped) {
            if (started) {
              updateDebugPanel("‚ùå ƒê√£ d·ª´ng h√†nh tr√¨nh");
              started = false;
              paused = false;
              updateControlButtons();
            }
          }
        })
        .catch(err => console.error("Error fetching route status:", err));
    }

    // Start auto-update status
    function startStatusUpdate() {
      if (statusUpdateInterval === null) {
        statusUpdateInterval = setInterval(fetchRouteStatus, 500);  // C·∫≠p nh·∫≠t m·ªói 0.5s
      }
    }

    // Stop auto-update status
    function stopStatusUpdate() {
      if (statusUpdateInterval !== null) {
        clearInterval(statusUpdateInterval);
        statusUpdateInterval = null;
      }
    }

    // S·ª± ki·ªán n√∫t
    document.addEventListener("DOMContentLoaded", function() {
      document.getElementById("btnStart").onclick = function() {
        if (paused) {
          // Ti·∫øp t·ª•c sau khi pause
          fetch("/resumeRoute", { method: "POST" })
            .then(r => r.text())
            .then(msg => {
              console.log("[RESUME ROUTE]", msg);
              paused = false;
              updateControlButtons();
              updateDebugPanel("‚ñ∂Ô∏è Ti·∫øp t·ª•c h√†nh tr√¨nh");
            })
            .catch(err => console.error(err));
        } else {
          // B·∫Øt ƒë·∫ßu m·ªõi
          started = true;
          paused = false;
          updateControlButtons();
          updateDebugPanel("üöÄ B·∫Øt ƒë·∫ßu h√†nh tr√¨nh...");
          
          // G·ª≠i l·ªánh b·∫Øt ƒë·∫ßu ƒë·∫øn server
          const params = new URLSearchParams({
            dis: dis.join(","),
            dir: dir.join(","),
            dir_value: dir_value.join(",")
          });
          fetch("/startRoute", {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: params
          })
          .then(r => r.text())
          .then(msg => {
            console.log("[START ROUTE]", msg);
            startStatusUpdate();  // B·∫Øt ƒë·∫ßu c·∫≠p nh·∫≠t status
          })
          .catch(err => {
            updateDebugPanel("‚ùå L·ªói: " + err.message);
            console.error(err);
          });
        }
      };
      
      document.getElementById("btnPause").onclick = function() {
        if (!paused) {
          // T·∫°m d·ª´ng
          fetch("/pauseRoute", { method: "POST" })
            .then(r => r.text())
            .then(msg => {
              console.log("[PAUSE ROUTE]", msg);
              paused = true;
              updateControlButtons();
              updateDebugPanel("‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng");
            })
            .catch(err => console.error(err));
        } else {
          // Ti·∫øp t·ª•c (gi·ªëng n√∫t Start khi paused)
          fetch("/resumeRoute", { method: "POST" })
            .then(r => r.text())
            .then(msg => {
              console.log("[RESUME ROUTE]", msg);
              paused = false;
              updateControlButtons();
              updateDebugPanel("‚ñ∂Ô∏è Ti·∫øp t·ª•c h√†nh tr√¨nh");
            })
            .catch(err => console.error(err));
        }
      };
      
      document.getElementById("btnStop").onclick = function() {
        // D·ª´ng h·∫≥n
        fetch("/stopRoute", { method: "POST" })
          .then(r => r.text())
          .then(msg => {
            console.log("[STOP ROUTE]", msg);
            started = false;
            paused = false;
            updateControlButtons();
            stopStatusUpdate();
            updateDebugPanel("üõë ƒê√£ d·ª´ng h√†nh tr√¨nh");
          })
          .catch(err => console.error(err));
      };
      
      updateControlButtons();
    });

    // Chuy·ªÉn sang trang Detection
    function goToDetection() {
      window.location.href = "/detection";
    }
  </script>

  <script async defer src="https://maps.googleapis.com/maps/api/js?key={{ GOOGLE_MAPS_API_KEY }}&callback=initMap"></script>
</body>
</html>
